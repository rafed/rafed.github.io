<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lab | Rafed M. Yasir</title><link>https://rafed.github.io/courses/distributed-systems/lab/</link><atom:link href="https://rafed.github.io/courses/distributed-systems/lab/index.xml" rel="self" type="application/rss+xml"/><description>Lab</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2024 Rafed Muhammad Yasir</copyright><lastBuildDate>Sun, 07 Feb 2021 00:00:00 +0000</lastBuildDate><image><url>https://rafed.github.io/media/icon_hu21e3d06fd85657997c5a756b8676c06c_23682_512x512_fill_lanczos_center_3.png</url><title>Lab</title><link>https://rafed.github.io/courses/distributed-systems/lab/</link></image><item><title>Containerizing an App</title><link>https://rafed.github.io/courses/distributed-systems/lab/containerization/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/containerization/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>You will build a simple web application and containerize it with docker.&lt;/p>
&lt;p>Follow the instructions in this &lt;a href="https://github.com/rafed/docker-intro" target="_blank" rel="noopener">Github repo&lt;/a> to complete this task.&lt;/p></description></item><item><title>Creating a pipeline</title><link>https://rafed.github.io/courses/distributed-systems/lab/pipeline/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/pipeline/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>You will learn to build a CI/CD pipeline using git, Github actions and Heroku.&lt;/p>
&lt;h2 id="instructions">Instructions&lt;/h2>
&lt;p>Follow the instructions in this &lt;a href="https://github.com/rafed/ci-cd-pipeline" target="_blank" rel="noopener">Github repo&lt;/a> to complete this task.&lt;/p></description></item><item><title>Ride sharing backend: From monolith to microservices</title><link>https://rafed.github.io/courses/distributed-systems/lab/microservice-ride-share/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/microservice-ride-share/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Your task is to build a distributed web system following the microservice architecture. It should be implemented following the steps below.&lt;/p>
&lt;h2 id="step-1-build-a-simple-server-and-a-client">Step 1: Build a simple server (and a client)&lt;/h2>
&lt;p>You will build a rudimentary version of a &lt;strong>Ride sharing app&lt;/strong> (like Uber/Pathao). The app itself will not be complex as we are here to build a distributed system and not a full-fledged app.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
A[&amp;quot;Client (Bot)&amp;quot;]--&amp;gt;B
B[Server]--&amp;gt;C[(Database)]
&lt;/code>&lt;/pre>
&lt;h3 id="requirements">Requirements&lt;/h3>
&lt;h4 id="client-bot">Client bot&lt;/h4>
&lt;p>The client bot will &lt;strong>spam the server every second&lt;/strong> with the following two http requests:&lt;/p>
&lt;ul>
&lt;li>Rider&amp;rsquo;s request contains:
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Rider&amp;rsquo;s Coordinates (x, y) [Random]&lt;/li>
&lt;li>Rider&amp;rsquo;s Destination (x, y) [Random]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Driver&amp;rsquo;s request contains:
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Car number&lt;/li>
&lt;li>Driver&amp;rsquo;s Coordinates [Random]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="server-requirements">Server requirements&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>/rider&lt;/strong> endpoint accepts rider requests (http)&lt;/li>
&lt;li>&lt;strong>/driver&lt;/strong> endpoint accepts driver requests (http)&lt;/li>
&lt;li>The server will store the information &lt;strong>in memory&lt;/strong> for &lt;strong>at least 5 seconds&lt;/strong>. Design a function that will periodically run on the cached information and make pairs (rider, driver) based on their shortest linear distance.&lt;/li>
&lt;li>Open a &lt;strong>socket.io&lt;/strong> bidirectional communication medium and send messages through the &lt;strong>/communication&lt;/strong> namespace. Messages from the server will be sent to the client through this channel.&lt;/li>
&lt;li>Send the ride fare to the client (linear distance * 2 taka) (through socket.io)&lt;/li>
&lt;li>&lt;strong>/rating&lt;/strong> endpoint receives a random rating after the bot receives a fare&lt;/li>
&lt;/ul>
&lt;h4 id="database">Database&lt;/h4>
&lt;ul>
&lt;li>The database only stores driver ratings&lt;/li>
&lt;li>Storing other information is not necessary (yet)&lt;/li>
&lt;li>Use mysql or mongodb as your database&lt;/li>
&lt;/ul>
&lt;h4 id="other-instructions">Other instructions&lt;/h4>
&lt;ul>
&lt;li>You may use any programming language. However, &lt;strong>Node.js or Python or Go&lt;/strong> is recommended&lt;/li>
&lt;li>Frameworks/libraries can be used. However, it&amp;rsquo;s best not to use full-fledged frameworks. Simpler frameworks (like express/flask/gin) will make things easier&lt;/li>
&lt;li>Don&amp;rsquo;t implement extra features. Because later, distributing them in multiple instances could turn out to be a problem&lt;/li>
&lt;/ul>
&lt;h2 id="step-2-service-into-microservices">Step 2: Service into microservices&lt;/h2>
&lt;p>If you have completed step 1, congratulations! By now you have learned how to-&lt;/p>
&lt;ul>
&lt;li>make APIs and call them&lt;/li>
&lt;li>make sockets for bidirectional communication&lt;/li>
&lt;li>make schedulers that call a function periodically&lt;/li>
&lt;li>integrate database with an application&lt;/li>
&lt;/ul>
&lt;p>If you have done all that, kudos to you! You are now ready to start building microservices (or more like breaking an app into microservices).&lt;/p>
&lt;h3 id="requirements-1">Requirements&lt;/h3>
&lt;p>Let&amp;rsquo;s recap what modules we have in our backend system so far:&lt;/p>
&lt;ul>
&lt;li>a rider module&lt;/li>
&lt;li>a driver module&lt;/li>
&lt;li>a rider/driver matching module&lt;/li>
&lt;li>a rating module connecting to a database&lt;/li>
&lt;li>a communication module for bidirectional communication&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;ll convert these modules to make three business services.&lt;/p>
&lt;ol>
&lt;li>Ride sharing service
&lt;ul>
&lt;li>rider module&lt;/li>
&lt;li>driver module&lt;/li>
&lt;li>rider/driver matching module&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Communication service&lt;/li>
&lt;li>Rating service&lt;/li>
&lt;/ol>
&lt;p>Our system architecture will be like the following.&lt;/p>
&lt;h3 id="architecture-1">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
A --- C[&amp;quot;Communication service (socket.io)&amp;quot;]
A[&amp;quot;Client (Bot)&amp;quot;]--&amp;gt;B[&amp;quot;Reverse Proxy (Nginx)&amp;quot;]
B--&amp;gt;R[Ride sharing service]
B--&amp;gt;Ra[Rating service]
Ra--&amp;gt;D[(Database)]
R--&amp;gt;C
&lt;/code>&lt;/pre>
&lt;h3 id="what-to-do">What to do?&lt;/h3>
&lt;ol>
&lt;li>In your project folder, make sub projects. Each sub project will be a separate service.&lt;/li>
&lt;li>Download and configure nginx so that it works as a reverse proxy for all http services (in our case &lt;strong>ride sharing service&lt;/strong> and &lt;strong>rating service&lt;/strong>).&lt;/li>
&lt;li>For nginx configuration Google is your friend. You can also follow their official docs at &lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/" target="_blank" rel="noopener">docs.nginx.com&lt;/a>.&lt;/li>
&lt;li>Write additional code so that the services communicate among themselves and the business logic discussed in &lt;em>step 1&lt;/em> is served.&lt;/li>
&lt;/ol>
&lt;h2 id="step-3-containerize-and-orchestrate">Step 3: Containerize and orchestrate&lt;/h2>
&lt;p>If you have completed step 2, congratulations! You have successfully created a distributed system and have a gotten a flavor of how microservices work!&lt;/p>
&lt;p>In this step we will do three things in our app-&lt;/p>
&lt;ul>
&lt;li>&lt;strong>containerize&lt;/strong> the services that we made&lt;/li>
&lt;li>use &lt;strong>pre built containers&lt;/strong> for &lt;em>mysql/mongo&lt;/em> and &lt;em>nginx&lt;/em>&lt;/li>
&lt;li>orchestrate our services&lt;/li>
&lt;/ul>
&lt;h3 id="self-learning">Self Learning&lt;/h3>
&lt;p>First, you will need to learn about containerization and orchestration &lt;strong>with docker&lt;/strong>. You can watch the following tutorials-&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gjnup-PuquQ" target="_blank" rel="noopener">Docker in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=gAkwW2tuIqE" target="_blank" rel="noopener">Docker in 7 easy steps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MVIcrmeV_6c" target="_blank" rel="noopener">Docker-compose tutorial&lt;/a>&lt;/li>
&lt;li>And please, Google some stuff yourself&lt;/li>
&lt;/ul>
&lt;p>Once you understand the fundamentals, you can refer to &lt;a href="https://rafed.github.io/devra/posts/docker/useful-docker-commands/" target="_blank" rel="noopener">this manual&lt;/a> to run the most commonly used docker commands.&lt;/p>
&lt;p>Additionally, check out &lt;a href="https://github.com/rafed/nginx-flask-docker" target="_blank" rel="noopener">this repo&lt;/a> for a demo web app that&amp;rsquo;s load balanced, containerized and orchestrated with docker.&lt;/p>
&lt;h3 id="what-to-do-1">What to do?&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Write a Dockerfile&lt;/strong> for each of the following service in their respective sub-project folder
&lt;ul>
&lt;li>ride sharing service&lt;/li>
&lt;li>rating servie&lt;/li>
&lt;li>communication service&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Write a docker-compose.yml file in the root project folder to orchestrate all of the services&lt;/li>
&lt;/ol>
&lt;h4 id="other-instructions-1">Other instructions&lt;/h4>
&lt;ol>
&lt;li>No change in the application code is necessary (Except maybe port numbers. You may want to reassign them).&lt;/li>
&lt;li>Windows cannot handle docker containers properly (even though Docker claims that they have support for windows). Use a Linux environment to run docker containers.&lt;/li>
&lt;/ol>
&lt;h2 id="step-4-geo-distribute-the-app">Step 4: Geo distribute the app&lt;/h2>
&lt;p>Our ride sharing app is becoming popular! We now want to go global!&lt;/p>
&lt;h3 id="architecture-2">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CD[&amp;quot;Client (Dhaka)&amp;quot;] --&amp;gt; ND[&amp;quot;Proxy (Dhaka)&amp;quot;]
CC[&amp;quot;Client (Chittagong)&amp;quot;] --&amp;gt; NC[&amp;quot;Proxy (Chittagong)&amp;quot;]
CD --&amp;gt; DNS[&amp;quot;DNS&amp;quot;]
CC --&amp;gt; DNS
ND --&amp;gt; RSSD[&amp;quot;Ride service (Dhaka)&amp;quot;]
ND --&amp;gt; RSD[&amp;quot;Rating service (Dhaka)&amp;quot;]
RSSD --&amp;gt; CSD[&amp;quot;Communication service (Dhaka)&amp;quot;]
CD --- CSD
RSD --&amp;gt; DBD[(&amp;quot;DB (Dhaka)&amp;quot;)]
NC --&amp;gt; RSSC[&amp;quot;Ride service (Chitt)&amp;quot;]
NC --&amp;gt; RSD
RSSC --&amp;gt; CSC[&amp;quot;Communication service (Chitt)&amp;quot;]
CC --- CSC
&lt;/code>&lt;/pre>
&lt;h2 id="step-5-more-development-bonus">Step 5: More development (Bonus)&lt;/h2>
&lt;h4 id="step-51-use-an-in-memory-database">Step 5.1: Use an in memory database&lt;/h4>
&lt;p>Our app has a big problem. The rider and driver list is stored in an array in memory. Imagine what will happen if we wanted to increase availability by creating multiple instances of the &amp;ldquo;Ride sharing service&amp;rdquo;. Can you figure out the problem?&lt;/p>
&lt;p>To solve this, instead of storing the data in memory, store it inside a redis container. The rider/driver matcher should pull data from the redis cache. (You may need to separate the rider/driver pair matcher to a separate service).&lt;/p>
&lt;h4 id="step-52-send-emails-with-message-queueing">Step 5.2: Send emails with message queueing&lt;/h4>
&lt;p>We need to do email marketing to our customers to let them know about our latest upgrades and features. Do this by:&lt;/p>
&lt;ol>
&lt;li>Install a rabbitmq container (rabbitmq is a message queue broker)&lt;/li>
&lt;li>Make a email service that has
&lt;ul>
&lt;li>a push to broker function to push addresses to the broker&lt;/li>
&lt;li>a &amp;ldquo;send email function&amp;rdquo; that periodically sends emails to the addresses stored in the message broker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Facebook backend: From monolith to microservices</title><link>https://rafed.github.io/courses/distributed-systems/lab/microservice-facebook/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/microservice-facebook/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Your task is to build a monolithic web based system. Then, break down the system into microservices following the microservice architecture. To acheive this follow the steps below.&lt;/p>
&lt;h2 id="step-1-build-a-server-and-a-client">Step 1: Build a server and a client&lt;/h2>
&lt;p>You will build a rudimentary version of &lt;strong>Facebook&lt;/strong>. The app itself should not be complex as we are here to build a distributed system and not a full featured social media app.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CLIENT[Client]--&amp;gt;SERVER[Server]
SERVER--&amp;gt;DB[(Database)]
SERVER--&amp;gt;OBJ_DB[(Object DB)]
&lt;/code>&lt;/pre>
&lt;h3 id="requirements">Requirements&lt;/h3>
&lt;h4 id="client-requirements">Client Requirements&lt;/h4>
&lt;p>The client UI will have three routes:&lt;/p>
&lt;ul>
&lt;li>Registration page&lt;/li>
&lt;li>Login page&lt;/li>
&lt;li>News feed page. A news feed will have
&lt;ul>
&lt;li>A horizontal list of stories at the top (images only)&lt;/li>
&lt;li>Status from different users (texts only, no comments)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="server-requirements">Server requirements&lt;/h4>
&lt;h5 id="apis">APIS&lt;/h5>
&lt;ul>
&lt;li>&lt;strong>/register&lt;/strong> endpoint for creating new users
&lt;ul>
&lt;li>user registers with email and password&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/login&lt;/strong> endpoint for logging (with JWT)
&lt;ul>
&lt;li>user logs in with email and password&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/status&lt;/strong> endpoint for creating and retrieving status
&lt;ul>
&lt;li>GET: Get latest 10 statuses of all users except logged in user&lt;/li>
&lt;li>POST: Create new status for user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/story&lt;/strong> endpoint for creating and retrieving stories
&lt;ul>
&lt;li>GET: Get latest 10 stories of all users except logged in user&lt;/li>
&lt;li>POST: Create new story for user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="system-assumptions">System assumptions&lt;/h5>
&lt;ul>
&lt;li>All users are friends by default&lt;/li>
&lt;li>The system needs no other services (e.g. messenger, poke, react)&lt;/li>
&lt;/ul>
&lt;h4 id="other-instructions">Other instructions&lt;/h4>
&lt;ul>
&lt;li>Images uploaded in stories should be stored in an object store database (MinIO)&lt;/li>
&lt;li>Frameworks/libraries can be used. However, using frameworks (like express/flask/fastapi/gin) will make the assignment easier.&lt;/li>
&lt;li>Using a framework on the frontend can be useful (angular/vue/react).&lt;/li>
&lt;li>Don&amp;rsquo;t implement extra features. Because, distributing them in multiple instances could turn out to be a problem later.&lt;/li>
&lt;li>You may use any programming language. However, &lt;strong>Node.js or Python or Go&lt;/strong> is recommended.&lt;/li>
&lt;/ul>
&lt;h2 id="step-2-service-into-microservices">Step 2: Service into microservices&lt;/h2>
&lt;p>If you have completed step 1, congratulations! By now you have learned how to-&lt;/p>
&lt;ul>
&lt;li>make APIs and call them (from a frontend)&lt;/li>
&lt;li>integrate database with an application&lt;/li>
&lt;li>use an object store database&lt;/li>
&lt;/ul>
&lt;p>If you have done all that, kudos! You are now ready to start building microservices (or more like breaking an app into microservices).&lt;/p>
&lt;h3 id="requirements-1">Requirements&lt;/h3>
&lt;p>Let&amp;rsquo;s recap what modules we have in our backend system so far:&lt;/p>
&lt;ul>
&lt;li>a Reg &amp;amp; Auth module&lt;/li>
&lt;li>a Story module&lt;/li>
&lt;li>a Status module&lt;/li>
&lt;/ul>
&lt;p>Currently these modules serve from a single monolith. We need to segregate them to the following services.&lt;/p>
&lt;ol>
&lt;li>User service
&lt;ul>
&lt;li>Registration&lt;/li>
&lt;li>Login&lt;/li>
&lt;li>Authentication&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Status service&lt;/li>
&lt;li>Story service&lt;/li>
&lt;/ol>
&lt;p>Our system architecture will be like the following.&lt;/p>
&lt;h3 id="architecture-1">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CLIENT[&amp;quot;Client&amp;quot;]--&amp;gt;PROXY[&amp;quot;Reverse Proxy (Nginx)&amp;quot;]
PROXY--&amp;gt;USER[User service]
PROXY--&amp;gt;STATUS[Status service]
PROXY--&amp;gt;STORY[Story service]
USER--&amp;gt;USER_DB[(User DB)]
STATUS--&amp;gt;STATUS_DB[(Status DB)]
STATUS--&amp;gt;USER
STORY--&amp;gt;STORY_DB[(Story DB)]
STORY--&amp;gt;OBJECT_DB[(Object DB)]
STORY--&amp;gt;USER
&lt;/code>&lt;/pre>
&lt;h3 id="what-to-do">What to do?&lt;/h3>
&lt;ol>
&lt;li>In your project folder, make sub projects. Each sub project will be a separate service.&lt;/li>
&lt;li>Download and configure nginx so that it works as a reverse proxy for all the services&lt;/li>
&lt;li>For nginx configuration Google is your friend. You can also follow their official docs at &lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/" target="_blank" rel="noopener">docs.nginx.com&lt;/a>.&lt;/li>
&lt;li>Write additional code so that the services communicate among themselves and the business logic discussed in &lt;em>step 1&lt;/em> is served.
&lt;ul>
&lt;li>You may need to check requests for &lt;strong>authorization&lt;/strong> when a user hits &lt;strong>status service&lt;/strong> and &lt;strong>story service&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Although it&amp;rsquo;s a best practice to use separate database instances for each service, we will ignore it now for simplicity. Don&amp;rsquo;t worry we&amp;rsquo;ll segregate the database in some later steps.&lt;/li>
&lt;/ol>
&lt;h2 id="step-3-containerize-and-orchestrate">Step 3: Containerize and orchestrate&lt;/h2>
&lt;p>If you have completed step 2, congratulations! You have successfully created a distributed system and have a got a flavor of how microservices work!&lt;/p>
&lt;p>In this step we will do three things in our app-&lt;/p>
&lt;ul>
&lt;li>&lt;strong>containerize&lt;/strong> the services that we made&lt;/li>
&lt;li>use &lt;strong>pre built containers&lt;/strong> for &lt;em>mysql/mongo&lt;/em> and &lt;em>nginx&lt;/em>&lt;/li>
&lt;li>and &lt;strong>orchestrate&lt;/strong> our services&lt;/li>
&lt;/ul>
&lt;h3 id="self-learning">Self Learning&lt;/h3>
&lt;p>First, you will need to learn about containerization and orchestration &lt;strong>with docker&lt;/strong>. You can watch the following tutorials-&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gjnup-PuquQ" target="_blank" rel="noopener">Docker in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=gAkwW2tuIqE" target="_blank" rel="noopener">Docker in 7 easy steps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MVIcrmeV_6c" target="_blank" rel="noopener">Docker-compose tutorial&lt;/a>&lt;/li>
&lt;li>And please, Google some stuff yourself&lt;/li>
&lt;/ul>
&lt;p>Once you understand the fundamentals, you can refer to &lt;a href="https://rafed.github.io/devra/posts/docker/useful-docker-commands/" target="_blank" rel="noopener">this manual&lt;/a> to run the most commonly used docker commands.&lt;/p>
&lt;!-- Additionally, check out [this repo](https://github.com/rafed/nginx-flask-docker) for a demo web app that's load balanced, containerized and orchestrated with docker. -->
&lt;h3 id="what-to-do-1">What to do?&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Write a Dockerfile&lt;/strong> for each of the services in their respective directories
&lt;ul>
&lt;li>User service&lt;/li>
&lt;li>Status service&lt;/li>
&lt;li>Story service&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Write a docker-compose.yml&lt;/strong> file in the root project folder to orchestrate all of the services&lt;/li>
&lt;li>&lt;strong>Use separate database&lt;/strong> (containers) for each service&lt;/li>
&lt;/ol>
&lt;p>&lt;em>N.B Follow the reference architecture in step 2&lt;/em>&lt;/p>
&lt;h4 id="other-instructions-1">Other instructions&lt;/h4>
&lt;ol>
&lt;li>No change in the application code is necessary (Except for maybe port numbers. You may want to reassign them).&lt;/li>
&lt;li>Windows cannot handle docker containers properly (even though Docker claims that they have support for windows). Use a Linux environment to run docker containers.&lt;/li>
&lt;/ol>
&lt;h2 id="step-4-deploy-in-a-swarm">Step 4: Deploy in a swarm&lt;/h2>
&lt;p>Great job guys! By now if you have successfully created a distributed system. However, the current system is distributed in software. What if we want to distribute our services in hardware?&lt;/p>
&lt;p>In this step we will distribute our services in hardware. We will create a cluster of computers at first (called a swarm). Then we will deploy our containers in it.&lt;/p>
&lt;p>This step by far should be the easiest (if you have done everything in the previous steps properly).&lt;/p>
&lt;h3 id="self-learning-1">Self Learning&lt;/h3>
&lt;p>Go through the following tutorials at first:&lt;/p>
&lt;ul>
&lt;li>The &lt;a href="https://docs.docker.com/engine/swarm/swarm-tutorial/" target="_blank" rel="noopener">official docker swarm docs&lt;/a> have a very good getting started tutorial. Go through it.&lt;/li>
&lt;li>Watch this video &lt;a href="https://www.youtube.com/watch?v=Tm0Q5zr3FL4" target="_blank" rel="noopener">www.youtube.com/watch?v=Tm0Q5zr3FL4&lt;/a>&lt;/li>
&lt;li>And please google some stuff yourself.&lt;/li>
&lt;/ul>
&lt;h3 id="what-to-do-2">What to do?&lt;/h3>
&lt;ul>
&lt;li>Create a team of two/three members (max three members per team)&lt;/li>
&lt;li>Create a docker swarm with two/three PCs&lt;/li>
&lt;li>Deploy each member&amp;rsquo;s facebook app in the swarm&lt;/li>
&lt;/ul>
&lt;h3 id="important-commands-when-creating-a-swarm">Important commands when creating a swarm&lt;/h3>
&lt;pre>&lt;code class="language-bash">$ docker create swarm
$ docker join swarm --token SWMTKN-1-26hm.....jxjxnj 192.168.x.xxx:2377
$ docker swarm leave --force
$ docker node ls
$ docker info # check current swarm status
$ docker stack deploy --compose-file docker-compose.yml bsse07xx
$ docker stack services bsse07xx
&lt;/code>&lt;/pre></description></item><item><title>LinkedIn backend: From monolith to microservices</title><link>https://rafed.github.io/courses/distributed-systems/lab/microservice-linkedin/</link><pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/microservice-linkedin/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Your task is to build a monolithic web based system. Then, break down the system into microservices following the microservice architecture. To acheive this follow the steps below.&lt;/p>
&lt;h2 id="step-1-build-a-server-and-a-client">Step 1: Build a server and a client&lt;/h2>
&lt;p>You will create a basic version of &lt;strong>LinkedIn&lt;/strong>. The app itself should not be complex as we are here to build a distributed system and not a full featured social media app.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CLIENT[Client]--&amp;gt;SERVER[Server]
SERVER--&amp;gt;DB[(Database)]
SERVER--&amp;gt;OBJ_DB[(Object DB)]
&lt;/code>&lt;/pre>
&lt;h3 id="requirements">Requirements&lt;/h3>
&lt;h4 id="client-requirements">Client Requirements&lt;/h4>
&lt;p>The client UI will have the following routes:&lt;/p>
&lt;ul>
&lt;li>Registration page&lt;/li>
&lt;li>Login page&lt;/li>
&lt;li>Home page: should show a vertical list of posts (texts/images)&lt;/li>
&lt;li>Notification page: should show notifications of recent posts
&lt;ul>
&lt;li>Clicking on the notification should show the post&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="server-requirements">Server requirements&lt;/h4>
&lt;h5 id="apis">APIS&lt;/h5>
&lt;ul>
&lt;li>&lt;strong>/register&lt;/strong> endpoint for creating new users
&lt;ul>
&lt;li>user registers with email and password&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/login&lt;/strong> endpoint for logging (with JWT)
&lt;ul>
&lt;li>user logs in with email and password&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/post&lt;/strong> endpoint for creating and retrieving posts
&lt;ul>
&lt;li>GET: Get latest posts of all users except logged in user&lt;/li>
&lt;li>POST: Create new posts for user&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>/notification&lt;/strong> endpoint for creating and retrieving notifications
&lt;ul>
&lt;li>GET: Get notifications&lt;/li>
&lt;li>POST: Create notification against a post&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="jobs">Jobs&lt;/h5>
&lt;ul>
&lt;li>Notification cleaner: A job should periodically check for old notifications and delete them&lt;/li>
&lt;/ul>
&lt;h5 id="system-assumptions">System assumptions&lt;/h5>
&lt;ul>
&lt;li>All users are friends/connected by default&lt;/li>
&lt;li>The system needs no other services (e.g. chat, comments, reacts)&lt;/li>
&lt;/ul>
&lt;h4 id="other-instructions">Other instructions&lt;/h4>
&lt;ul>
&lt;li>Images uploaded for posts should be stored in an object store database (MinIO)&lt;/li>
&lt;li>You may use any programming language. However, &lt;strong>Node.js or Python or Go&lt;/strong> is recommended.&lt;/li>
&lt;li>Frameworks/libraries can be used. However, using frameworks (like express/flask/fastapi/gin) will make the assignment easier.&lt;/li>
&lt;li>Using a framework on the frontend can be useful (angular/vue/react).&lt;/li>
&lt;li>You can use any database. Mongo recommended.&lt;/li>
&lt;li>Don&amp;rsquo;t implement extra features. Because, distributing them in multiple instances could turn out to be a problem later.&lt;/li>
&lt;/ul>
&lt;h2 id="step-2-decompose-to-microservices-containerize-and-orchestrate">Step 2: Decompose to microservices, containerize and orchestrate&lt;/h2>
&lt;p>If you have completed step 1, congratulations! By now you have learned how to-&lt;/p>
&lt;ul>
&lt;li>make APIs and call them (from a frontend)&lt;/li>
&lt;li>integrate database with an application&lt;/li>
&lt;li>use an object store database&lt;/li>
&lt;/ul>
&lt;p>If you have done all that, kudos! You are now ready to start building microservices (or more like breaking an app into microservices).&lt;/p>
&lt;h3 id="requirements-1">Requirements&lt;/h3>
&lt;p>Currently our application is a monolith. It&amp;rsquo;s time we convert it to a microservice applitcation.&lt;/p>
&lt;p>Let&amp;rsquo;s recap what modules we have in our backend system so far:&lt;/p>
&lt;ul>
&lt;li>User management module (Registration, Login)&lt;/li>
&lt;li>Posts module&lt;/li>
&lt;li>Notification module&lt;/li>
&lt;/ul>
&lt;p>Currently these modules form a single monolith. We need to segregate them to the following services.&lt;/p>
&lt;ol>
&lt;li>User service
&lt;ul>
&lt;li>Registration&lt;/li>
&lt;li>Login&lt;/li>
&lt;li>Authentication&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Posts service&lt;/li>
&lt;li>Notification service&lt;/li>
&lt;/ol>
&lt;p>In addition, we also need to develop a sustainable system/environment where we can build/run the microservices easily.&lt;/p>
&lt;p>Our expected system architecture will be like the following.&lt;/p>
&lt;h3 id="architecture-1">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CLIENT[&amp;quot;Client&amp;quot;]--&amp;gt;PROXY[&amp;quot;Reverse Proxy (Nginx)&amp;quot;]
PROXY--&amp;gt;USER[User service]
PROXY--&amp;gt;POST[Post service]
PROXY--&amp;gt;NOTIFICATION[Notification service]
USER--&amp;gt;USER_DB[(User DB)]
POST--&amp;gt;POST_DB[(Post DB)]
POST--&amp;gt;OBJECT_DB[(Object DB)]
POST--&amp;gt;USER
NOTIFICATION--&amp;gt;NOTIFICATION_DB[(Notif DB)]
NOTIFICATION--&amp;gt;USER
&lt;/code>&lt;/pre>
&lt;h3 id="what-to-do">What to do?&lt;/h3>
&lt;ol>
&lt;li>In your project folder, make sub projects. Each sub project will be a separate microservice.&lt;/li>
&lt;li>Decompose the monolith into microservices so that each microservice is in a sub-project.&lt;/li>
&lt;li>Containerize each service using Docker&lt;/li>
&lt;li>Orchestrate the services by writing a docker-compose file&lt;/li>
&lt;li>Make sure to have an nginx container so that ALL traffic is routed through nginx and delivered to the respective services&lt;/li>
&lt;li>Write additional code so that the services communicate among themselves and the business logic discussed in &lt;em>step 1&lt;/em> is served.
&lt;ul>
&lt;li>You may need to check requests for &lt;strong>authorization&lt;/strong> when a user hits &lt;strong>post service&lt;/strong> and &lt;strong>notification service&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="suggestionslearning-materials">Suggestions/Learning Materials&lt;/h3>
&lt;ol>
&lt;li>Take your time to do the assignment. Instead of seeing it as one large task, try completing it taking one step at a time.&lt;/li>
&lt;li>For writing nginx configurations Google is your friend. You can also follow their official docs at &lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/" target="_blank" rel="noopener">docs.nginx.com&lt;/a>.&lt;/li>
&lt;li>Easy tutorials on containerizing with Docker
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gjnup-PuquQ" target="_blank" rel="noopener">Docker in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=gAkwW2tuIqE" target="_blank" rel="noopener">Docker in 7 easy steps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MVIcrmeV_6c" target="_blank" rel="noopener">Docker-compose tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rafed.github.io/devra/posts/docker/useful-docker-commands/" target="_blank" rel="noopener">My personal docker cheatsheet&lt;/a>&lt;/li>
&lt;li>And please, Google some stuff yourself&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>For inspiration, you can check out &lt;a href="https://github.com/rafed/nginx-flask-docker" target="_blank" rel="noopener">this repo&lt;/a> for a demo web app that&amp;rsquo;s load balanced, containerized and orchestrated with docker.&lt;/li>
&lt;/ol>
&lt;p>Good Luck!&lt;/p></description></item></channel></rss>