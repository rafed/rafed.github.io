<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lab | Rafed M. Yasir</title><link>https://rafed.github.io/courses/distributed-systems/lab/</link><atom:link href="https://rafed.github.io/courses/distributed-systems/lab/index.xml" rel="self" type="application/rss+xml"/><description>Lab</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021 Rafed Muhammad Yasir</copyright><lastBuildDate>Sun, 07 Feb 2021 00:00:00 +0000</lastBuildDate><image><url>https://rafed.github.io/images/icon_hu21e3d06fd85657997c5a756b8676c06c_23682_512x512_fill_lanczos_center_2.png</url><title>Lab</title><link>https://rafed.github.io/courses/distributed-systems/lab/</link></image><item><title>Containerizing an App</title><link>https://rafed.github.io/courses/distributed-systems/lab/containerization/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/containerization/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>You will build a simple web application and containerize it with docker.&lt;/p>
&lt;p>Follow the instructions in this &lt;a href="https://github.com/rafed/hello-docker" target="_blank" rel="noopener">Github repo&lt;/a> to complete this task.&lt;/p></description></item><item><title>Hands on DevOps</title><link>https://rafed.github.io/courses/distributed-systems/lab/devops/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/devops/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>You will learn to build a CI/CD pipeline using git, Github actions and Heroku.&lt;/p>
&lt;h2 id="instructions">Instructions&lt;/h2>
&lt;p>Follow the instructions in this &lt;a href="https://github.com/rafed/ci-cd-pipeline" target="_blank" rel="noopener">Github repo&lt;/a> to complete this task.&lt;/p></description></item><item><title>Making an app with microservice architecture</title><link>https://rafed.github.io/courses/distributed-systems/lab/microservices/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://rafed.github.io/courses/distributed-systems/lab/microservices/</guid><description>&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Your task is to build a distributed web system following the microservice architecture. It should be implemented following the steps below.&lt;/p>
&lt;h2 id="step-1-build-a-simple-server-and-a-client">Step 1: Build a simple server (and a client)&lt;/h2>
&lt;p>You will build a rudimentary version of a &lt;strong>Ride sharing app&lt;/strong> (like Uber/Pathao). The app itself will not be complex as we are here to build a distributed system and not a full-fledged app.&lt;/p>
&lt;h3 id="architecture">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
A[&amp;quot;Client (Bot)&amp;quot;]--&amp;gt;B
B[Server]--&amp;gt;C[(Database)]
&lt;/code>&lt;/pre>
&lt;h3 id="requirements">Requirements&lt;/h3>
&lt;h4 id="client-bot">Client bot&lt;/h4>
&lt;p>The client bot will &lt;strong>spam the server every second&lt;/strong> with the following two http requests:&lt;/p>
&lt;ul>
&lt;li>Rider&amp;rsquo;s request contains:
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Rider&amp;rsquo;s Coordinates (x, y) [Random]&lt;/li>
&lt;li>Rider&amp;rsquo;s Destination (x, y) [Random]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Driver&amp;rsquo;s request contains:
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Car number&lt;/li>
&lt;li>Driver&amp;rsquo;s Coordinates [Random]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="server-requirements">Server requirements&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>/rider&lt;/strong> endpoint accepts rider requests (http)&lt;/li>
&lt;li>&lt;strong>/driver&lt;/strong> endpoint accepts driver requests (http)&lt;/li>
&lt;li>The server will store the information &lt;strong>in memory&lt;/strong> for &lt;strong>at least 5 seconds&lt;/strong>. Design a function that will periodically run on the cached information and make pairs (rider, driver) based on their shortest linear distance.&lt;/li>
&lt;li>Open a &lt;strong>socket.io&lt;/strong> bidirectional communication medium and send messages through the &lt;strong>/communication&lt;/strong> namespace. Messages from the server will be sent to the client through this channel.&lt;/li>
&lt;li>Send the ride fare to the client (linear distance * 2 taka) (through socket.io)&lt;/li>
&lt;li>&lt;strong>/rating&lt;/strong> endpoint receives a random rating after the bot receives a fare&lt;/li>
&lt;/ul>
&lt;h4 id="database">Database&lt;/h4>
&lt;ul>
&lt;li>The database only stores driver ratings&lt;/li>
&lt;li>Storing other information is not necessary (yet)&lt;/li>
&lt;li>Use mysql or mongodb as your database&lt;/li>
&lt;/ul>
&lt;h4 id="other-instructions">Other instructions&lt;/h4>
&lt;ul>
&lt;li>You may use any programming language. However, &lt;strong>Node.js or Python or Go&lt;/strong> is recommended&lt;/li>
&lt;li>Frameworks/libraries can be used. However, it&amp;rsquo;s best not to use full-fledged frameworks. Simpler frameworks (like express/flask/gin) will make things easier&lt;/li>
&lt;li>Don&amp;rsquo;t implement extra features. Because later, distributing them in multiple instances could turn out to be a problem&lt;/li>
&lt;/ul>
&lt;h2 id="step-2-service-into-microservices">Step 2: Service into microservices&lt;/h2>
&lt;p>If you have completed step 1, congratulations! By now you have learned how to-&lt;/p>
&lt;ul>
&lt;li>make APIs and call them&lt;/li>
&lt;li>make sockets for bidirectional communication&lt;/li>
&lt;li>make schedulers that call a function periodically&lt;/li>
&lt;li>integrate database with an application&lt;/li>
&lt;/ul>
&lt;p>If you have done all that, kudos to you! You are now ready to start building microservices (or more like breaking an app into microservices).&lt;/p>
&lt;h3 id="requirements-1">Requirements&lt;/h3>
&lt;p>Let&amp;rsquo;s recap what modules we have in our backend system so far:&lt;/p>
&lt;ul>
&lt;li>a rider module&lt;/li>
&lt;li>a driver module&lt;/li>
&lt;li>a rider/driver matching module&lt;/li>
&lt;li>a rating module connecting to a database&lt;/li>
&lt;li>a communication module for bidirectional communication&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;ll convert these modules to make three business services.&lt;/p>
&lt;ol>
&lt;li>Ride sharing service
&lt;ul>
&lt;li>rider module&lt;/li>
&lt;li>driver module&lt;/li>
&lt;li>rider/driver matching module&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Communication service&lt;/li>
&lt;li>Rating service&lt;/li>
&lt;/ol>
&lt;p>Our system architecture will be like the following.&lt;/p>
&lt;h3 id="architecture-1">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
A --- C[&amp;quot;Communication service (socket.io)&amp;quot;]
A[&amp;quot;Client (Bot)&amp;quot;]--&amp;gt;B[&amp;quot;Reverse Proxy (Nginx)&amp;quot;]
B--&amp;gt;R[Ride sharing service]
B--&amp;gt;Ra[Rating service]
Ra--&amp;gt;D[(Database)]
R--&amp;gt;C
&lt;/code>&lt;/pre>
&lt;h3 id="what-to-do">What to do?&lt;/h3>
&lt;ol>
&lt;li>In your project folder, make sub projects. Each sub project will be a separate service.&lt;/li>
&lt;li>Download and configure nginx so that it works as a reverse proxy for all http services (in our case &lt;strong>ride sharing service&lt;/strong> and &lt;strong>rating service&lt;/strong>).&lt;/li>
&lt;li>For nginx configuration Google is your friend. You can also follow their official docs at &lt;a href="https://docs.nginx.com/nginx/admin-guide/basic-functionality/managing-configuration-files/" target="_blank" rel="noopener">docs.nginx.com&lt;/a>.&lt;/li>
&lt;li>Write additional code so that the services communicate among themselves and the business logic discussed in &lt;em>step 1&lt;/em> is served.&lt;/li>
&lt;/ol>
&lt;h2 id="step-3-containerize-and-orchestrate">Step 3: Containerize and orchestrate&lt;/h2>
&lt;p>If you have completed step 2, congratulations! You have successfully created a distributed system and have a gotten a flavor of how microservices work!&lt;/p>
&lt;p>In this step we will do three things in our app-&lt;/p>
&lt;ul>
&lt;li>&lt;strong>containerize&lt;/strong> the services that we made&lt;/li>
&lt;li>use &lt;strong>pre built containers&lt;/strong> for &lt;em>mysql/mongo&lt;/em> and &lt;em>nginx&lt;/em>&lt;/li>
&lt;li>orchestrate our services&lt;/li>
&lt;/ul>
&lt;h3 id="self-learning">Self Learning&lt;/h3>
&lt;p>First, you will need to do learn about containerization and orchestration &lt;strong>with docker&lt;/strong>. You can watch the following tutorials-&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Gjnup-PuquQ" target="_blank" rel="noopener">Docker in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=gAkwW2tuIqE" target="_blank" rel="noopener">Docker in 7 easy steps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MVIcrmeV_6c" target="_blank" rel="noopener">Docker-compose tutorial&lt;/a>&lt;/li>
&lt;li>And please, Google some stuff yourself&lt;/li>
&lt;/ul>
&lt;p>Once you understand the fundamentals, you can refer to &lt;a href="https://rafed.github.io/devra/posts/docker/useful-docker-commands/" target="_blank" rel="noopener">this manual&lt;/a> to run the most commonly used docker commands.&lt;/p>
&lt;p>Additionally check out &lt;a href="https://github.com/rafed/nginx-flask-docker" target="_blank" rel="noopener">this repo&lt;/a> for a demo web app that&amp;rsquo;s load balanced, containerized and orchestrated with docker.&lt;/p>
&lt;h3 id="what-to-do-1">What to do?&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Write a Dockerfile&lt;/strong> for each of the following service in their respective sub-project folder
&lt;ul>
&lt;li>ride sharing service&lt;/li>
&lt;li>rating servie&lt;/li>
&lt;li>communication service&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Write a docker-compose.yml file in the root project folder to orchestrate all of the services&lt;/li>
&lt;/ol>
&lt;h4 id="other-instructions-1">Other instructions&lt;/h4>
&lt;ol>
&lt;li>No change in the application code is necessary (Except maybe port numbers. You may want to reassign them).&lt;/li>
&lt;li>Windows cannot handle docker containers properly (even though Docker claims that they have support for windows). Use a Linux environment to run docker containers.&lt;/li>
&lt;/ol>
&lt;h2 id="step-4-geo-distribute-the-app">Step 4: Geo distribute the app&lt;/h2>
&lt;p>Our ride sharing app is becoming popular! We now want to go global!&lt;/p>
&lt;h3 id="architecture-2">Architecture&lt;/h3>
&lt;pre>&lt;code class="language-mermaid">graph TD
CD[&amp;quot;Client (Dhaka)&amp;quot;] --&amp;gt; ND[&amp;quot;Proxy (Dhaka)&amp;quot;]
CC[&amp;quot;Client (Chittagong)&amp;quot;] --&amp;gt; NC[&amp;quot;Proxy (Chittagong)&amp;quot;]
CD --&amp;gt; DNS[&amp;quot;DNS&amp;quot;]
CC --&amp;gt; DNS
ND --&amp;gt; RSSD[&amp;quot;Ride service (Dhaka)&amp;quot;]
ND --&amp;gt; RSD[&amp;quot;Rating service (Dhaka)&amp;quot;]
RSSD --&amp;gt; CSD[&amp;quot;Communication service (Dhaka)&amp;quot;]
CD --- CSD
RSD --&amp;gt; DBD[(&amp;quot;DB (Dhaka)&amp;quot;)]
NC --&amp;gt; RSSC[&amp;quot;Ride service (Chitt)&amp;quot;]
NC --&amp;gt; RSD
RSSC --&amp;gt; CSC[&amp;quot;Communication service (Chitt)&amp;quot;]
CC --- CSC
&lt;/code>&lt;/pre>
&lt;h2 id="step-5-more-development-bonus">Step 5: More development (Bonus)&lt;/h2>
&lt;h4 id="step-51-use-an-in-memory-database">Step 5.1: Use an in memory database&lt;/h4>
&lt;p>Our app has a big problem. The rider and driver list is stored in an array in memory. Imagine what will happen if we wanted to increase availability by creating multiple instances of the &amp;ldquo;Ride sharing service&amp;rdquo;. Can you figure out the problem?&lt;/p>
&lt;p>To solve this, instead of storing the data in memory, store it inside a redis container. The rider/driver matcher should pull data from the redis cache. (You may need to separate the rider/driver pair matcher to a separate service).&lt;/p>
&lt;h4 id="step-52-send-emails-with-message-queueing">Step 5.2: Send emails with message queueing&lt;/h4>
&lt;p>We need to do email marketing to our customers to let them know about our latest upgrades and features. Do this by:&lt;/p>
&lt;ol>
&lt;li>Install a rabbitmq container (rabbitmq is a message queue broker)&lt;/li>
&lt;li>Make a email service that has
&lt;ul>
&lt;li>a push to broker function to push addresses to the broker&lt;/li>
&lt;li>a &amp;ldquo;send email function&amp;rdquo; that periodically sends emails to the addresses stored in the message broker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item></channel></rss>